#****h* SpecTcl/menueditor.tk
# DESCRIPTION
#   Extra code for the menueditor
#
# CREATION DATE
#   3rd May 2001
#
# COPYRIGHT
#   Morten Skaarup Jensen 2001
#***



uplevel #0 {

catch {namespace eval menueditor {}} ;# To activate the namespace

#****v* SpecTcl/menueditor::menulist
# DESCRIPTION
# EXAMPLE
#   lappend ::menueditor::menulist {menu#2 menubutton.m}
# 
# SOURCE
#
set ::menueditor::menulist [list]
#***



#****v* SpecTcl/menueditor::currentmenu
# DESCRIPTION
#   Array with details about the menu currently being edited
# 
# SOURCE
#
array set ::menueditor::currentmenu {number -1 ident menu#? item_name m?.m?}
#***



#****v* SpecTcl/menueditor::currentmenu
# DESCRIPTION
#    The current position in the current menu
# 
# SOURCE
#
set ::menueditor::pos 0
#***



#****f* SpecTcl/menueditor::init
# DESCRIPTION
#    Initialises the Menueditor window
# SOURCE
#
proc ::menueditor::init {root} {
   # Create the variables $root, $base and $mbase
   set ::menueditor::root $root
   regsub {\.$} $root {} ::menueditor::base
   set ::menueditor::mbase $::menueditor::base.demomenu
   # Create the $menulist variable
   set ::menueditor::menulist [list]
   foreach item [uplevel #0 array names Widgets] {
      upvar #0 $item wdata
      if {"$wdata(type)"=="menu"} {
         lappend ::menueditor::menulist [list $item $wdata(item_name)]
         $::menueditor::base.lbEntries insert end $wdata(item_name)
      }
   }
}
#***



#****f* SpecTcl/menueditor::view
# DESCRIPTION
#   Displays the demomenu for the menueditor window
# SOURCE
#
proc ::menueditor::view {} {
   $::menueditor::mbase post 0 0
   set ::menueditor::pos 0
   catch {$::menueditor::mbase activate $::menueditor::pos}
}
#***



#****f* SpecTcl/menueditor::CreateTheOptionmenu
# DESCRIPTION
# Creates the menu for the option menu in the menueditor window
# SOURCE
#
proc ::menueditor::CreateTheOptionmenu {menu} {
   menu $menu -tearoff 0
   set root [winfo toplevel [winfo parent $menu]]
   regsub {\.$} $root {} base

   global sTatE
   array set sTatE {command,Label	normal
      cascade,Label	normal
      separator,Label	disabled
      checkbutton,Label	normal
      radiobutton,Label	normal
   }

   foreach type {command cascade separator checkbutton radiobutton} {
      $menu add radio -label $type \
         -value $type \
         -variable mbType.value \
         -command "
            foreach tmp {Label} {
               $base.e\$tmp config -state \$sTatE($type,\$tmp)
            }
         "
   }
   $menu invoke 0

# Arrow keys in entry widgets must override arrow keys in
# $root except at the beginning or end of the input string
foreach item {Label Command Variable Menu} {
   set w $::menueditor::base.e$item
   bind $w <Key-Left> "
      if {\[$w index insert\]>0} {
         $w icursor \[expr {\[$w index insert\]-1}\]
         break  ;# So that $root binding is not executed
      }
   "
   bind $w <Key-Right> "
      if {\[$w index insert\]<\[$w index end\]} {
         $w icursor \[expr {\[$w index insert\]+1}\]
         break  ;# So that $root binding is not executed
      }
   "
}

# Selection callback in listbox
set l $::menueditor::base.lbEntries
rename $l ::menueditor::.l
proc ::$l {args} {
   puts $args
   if {[regexp {^selection$} [lindex $args 0]] &&
       [regexp {^set$} [lindex $args 1]]} {
      ::menueditor::displaymenu $::menueditor::mbase [::menueditor::.l index [lindex $args 2]]
   }
   uplevel ::menueditor::.l $args
}

catch {$l selection set 0}
catch {$::menueditor::mbase activate 0}
}
#***



#****f* SpecTcl/menueditor::new
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::new {} {
   set tmp 1
   while {[info exists ::menu#$tmp]} {incr tmp}
   set ident menu#$tmp
   global Widgets $ident
   menu .can.f.$ident
   set Widgets($ident) 1
   set name $ident ;# Just temporarily
   array set $ident [list type menu item_name $name gadgets {}]
   lappend ::menueditor::menulist [list $ident $name]
   $::menueditor::base.lbEntries insert end $name
   $::menueditor::base.lbEntries activate end
   $::menueditor::base.lbEntries see active
   $::menueditor::base.lbEntries selection clear 0 end
   $::menueditor::base.lbEntries selection set active
   return $ident
}
#***



#****f* SpecTcl/menueditor::remove
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::remove {} {
   if {"[tk_messageBox -icon question -type yesno -parent $::menueditor::root -message "Are you sure?"]"!="yes"} {
      return
   }
   set number [$::menueditor::base.lbEntries curselection]
   if {"$number"==""} {
      return
   }
   set ident [lindex [lindex $::menueditor::menulist $number] 0]
   global Widgets $ident
   destroy .can.f.$ident
   unset Widgets($ident)
   unset $ident
   set ::menueditor::menulist [lreplace $::menueditor::menulist $number $number]
   $::menueditor::base.lbEntries delete $number
   $::menueditor::base.lbEntries selection set active
}
#***



#****f* SpecTcl/menueditor::displaymenu
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::displaymenu {mbase {number 0}} {
   set ident [lindex [lindex [set ::menueditor::menulist] $number] 0]
   upvar #0 $ident Ident
   array set ::menueditor::currentmenu [list number $number ident $ident item_name $Ident(item_name)]
   
   # Start a fresh
   catch {destroy $mbase} out 
   
   # Create menu
   menu $mbase -tearoff 0
   foreach {item opts} $Ident(gadgets) {
      $mbase add $item
      foreach {opt val} $opts {
         switch -- $opt {
            -command -
            -menu -
            -variable {}
            default {
              $mbase entryconfig last $opt $val
            }
         }
      }
   }
   $mbase post 0 0
   set ::menueditor::pos 0
   catch {$mbase activate $::menueditor::pos}
}
#***



#****f* SpecTcl/menueditor::insert
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::insert {} {
   upvar #0 [set ::menueditor::currentmenu(ident)] Ident
   set Ident(gadgets) [linsert $Ident(gadgets) [expr $::menueditor::pos*2] command {}]
   $::menueditor::mbase insert $::menueditor::pos command
   $::menueditor::mbase activate $::menueditor::pos
}
#***



#****f* SpecTcl/menueditor::add
# DESCRIPTION
#   Add new item to the current menu
#
# SOURCE
#
proc ::menueditor::add {} {
   upvar #0 [set ::menueditor::currentmenu(ident)] Ident
   set ::menueditor::pos [expr [llength $Ident(gadgets)]/2]
   lappend Ident(gadgets) command {}
   $::menueditor::mbase add command
   $::menueditor::mbase activate $::menueditor::pos
}
#***



#****f* SpecTcl/menueditor::replace
# DESCRIPTION
#   Change the currently selected item to the current menu
#
# SOURCE
#
proc ::menueditor::replace {} {
   set type ${::mbType.value}
   set opts [list -label [$::menueditor::base.eLabel get]]
   $::menueditor::mbase delete $::menueditor::pos
   $::menueditor::mbase insert $::menueditor::pos $type
   eval $::menueditor::mbase entryconfigure $::menueditor::pos $opts
   upvar #0 [set ::menueditor::currentmenu(ident)] Ident
   set Ident(gadgets) [lreplace $Ident(gadgets) [expr $::menueditor::pos*2] [expr $::menueditor::pos*2+1] $type $opts]
   $::menueditor::mbase activate $::menueditor::pos
}
#***



#****f* SpecTcl/menueditor::tearoff
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::tearoff {} {
   $::menueditor::mbase config -tearoff ${::cbTearoff.value}
}
#***



#****f* SpecTcl/menueditor::delete
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::delete {} {
   upvar #0 [set ::menueditor::currentmenu(ident)] Ident
   set Ident(gadgets) [lreplace $Ident(gadgets) [expr $::menueditor::pos*2] [expr $::menueditor::pos*2+1]]
   $::menueditor::mbase delete $::menueditor::pos
   catch {$::menueditor::mbase activate $::menueditor::pos}
}
#***



#****f* SpecTcl/menueditor::keyup
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::keyup {} {
   incr ::menueditor::pos -1
   if {$::menueditor::pos<0} {set ::menueditor::pos 0}
   catch {$::menueditor::mbase activate $::menueditor::pos}
}
#***



#****f* SpecTcl/menueditor::keydown
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::keydown {} {
   if {"[focus]"=="$::menueditor::base.lbEntries"} {return}
   upvar #0 [set ::menueditor::currentmenu(ident)] Ident
   set lastpos [expr [llength $Ident(gadgets)]/2-1]
   incr ::menueditor::pos
   if {$::menueditor::pos>$lastpos} {
      ::menueditor::add
   } else {
      $::menueditor::mbase activate $::menueditor::pos
   }
}
#***



#****f* SpecTcl/menueditor::keyleft
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::keyleft {} {
}
#***



#****f* SpecTcl/menueditor::keyright
# DESCRIPTION
#
# SOURCE
#
proc ::menueditor::keyright {} {
}
#***


} ;# End uplevel
