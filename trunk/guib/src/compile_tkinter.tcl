# compile_tkinter.tcl --
#
#	This file implements tkinter code generation and testing
#
# Copyright (c) 2006 ActiveState Software Inc
#
# See the file "license.terms" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

namespace eval ::tkinter {}

# ::tkinter::init --
#
#   Called whenever Tkinter is being used as the target language
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::tkinter::init {version interp args} {
    variable interpreter $interp

    if {$interp == "" || ![file exists $interp]} {
	# Don't use pythonw on Windows as we are always controlling over
	# a pipe and don't want to miss std channel output
	set interpreter [auto_execok python]
    }

    set ::P(file_suffix)	".ui"	;# user interface file suffix
    set ::P(target_suffix)	"_ui.py";# generated code file suffix
    set ::P(include_suffix)	".py"	;# included code file suffix
}

proc ::tkinter::interpreter {{interp ""} args} {
    variable interpreter
    if {$interp != ""} {
	set interpreter $interp
    }
    return $interpreter
}

namespace eval ::compile::tkinter {}

# init --
#
#   initialize for generating script in target language
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::init {ver args} {
    # tkinter SPECIFIC
    variable use_images ; catch {unset use_images} ; array set use_images {}
    variable use_vars ""
    variable indent ""
    variable widget_cmds ""
    variable bindtags ""
    variable REQS
    catch {unset REQS}
    array set REQS {}
}

# quote --
#
#   Quotes an option value appropriate to the language.
#
# Arguments:
#   str		string to quote
# Results:
#   Returns string in form ready to be placed in ""ed script.
#
proc ::compile::tkinter::quote {str} {
    # [[=]] is the marker to indicate user-exact syntax.
    if {[string range $str 0 4] eq {[[=]]}} {
	return [string range $str 5 end]
    } elseif {[string is double -strict $str]} {
	# int or double, don't quote
	return $str
    } elseif {![string is ascii $str]} {
	# Contains high-bit chars - translate
	set out ""
	foreach c [split $str ""] {
	    scan $c %c val
	    if {$val > 127} {
		append out "\\u[format %.4X $val]"
	    } else {
		append out $c
	    }
	}
	return u"$out"
    }
    if {$str eq "None"} {
	# None is a keyword
	return $str
    } else {
	# use single quotes to allow \ interpolation
	return \"$str\"
    }
}

# comment --
#
#   return commented text
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::comment {txt {prenew 2} args} {
    variable indent
    regsub -all {(\n)(\s*)(\S)} $txt "\\1${indent}#\\2\\3" txt
    return "[string repeat "\n" $prenew]${indent}# [string trimleft $txt]\n"
}

# command --
#
#   return command given parameters
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::command {prefix name arglist body {desc ""} args} {
    if {$name == "main"} {
	# we own this one, so skip it
	return
    }
    variable indent

    set script ""
    append script "${indent}# $name --\n${indent}#\n"
    if {$desc != ""} {
	append script [comment $desc 0]
    } else {
	append script "${indent}#   add comments here ...\n"
    }
    if {$body == ""} {
        set body "${indent}    pass"
    }
    append script "${indent}def ${name}($arglist):\n$body\n"
    return $script
}

# option --
#
#   Filter widget options to arrange for any necessary begin/end code
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::option {cmd name option value args} {
    # tkinter process textvariables
    variable use_images
    variable use_vars

    # Only StringVar (text|list|)variable bare word values (w/o object refs)
    if {[string match "-*variable" $option] && ![string match *.* $value]} {
	lappend use_vars $value
    } elseif {$option eq "-image" && $value ne ""} {
	# This image should already be created by name, but the name
	# may be a relative path - ensure it's "relatively absolute"
	if {[file pathtype $value] eq "relative"} {
	    set use_images($value) "os.path.dirname(__file__) + '/$value'"
	} else {
	    set use_images($value) "'$value'"
	}
    }
}

# require --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::require {type w args} {
    # We want to check the require type to get package require's right
    variable REQS
    set req [::widget::get $type requires]
    if {$req eq "Tk"} {
	set REQS(Tkinter) ""
    } else {
	set REQS($req) ""
    }
}

# targetHeader --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::targetHeader {file uifile prefix args} {
    variable REQS

    set header [string map [list "\#" ""] \
		    [::compile::fileHeader $file $uifile]]
    append script "\"\"\"$header" \
	    "THIS IS AN AUTOGENERATED FILE AND SHOULD NOT BE EDITED.\n" \
	    "The associated callback file should be modified instead.\n" \
	    "\"\"\"\n\n"

    foreach grp [array names REQS] {
	append script "import $grp\n"
    }
    append script "import os \# needed for relative image paths\n"
    append script "\n"

    return $script
}

# targetFooter --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::targetFooter {prefix args} {
    return "\n"
}

# includeHeader --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::includeHeader {file uifile prefix args} {
    set script ""
    if {[string equal $::tcl_platform(platform) "unix"]} {
	append script [unix_stub]
    }
    set header [string map [list "\#" ""] \
		    [::compile::fileHeader $file $uifile]]
    append script "\"\"\"$header" \
	" This file is auto-generated.  Only the code within\n" \
	"    '# BEGIN USER CODE (global|class)'\n" \
	"    '# END USER CODE (global|class)'\n" \
	" and code inside the callback subroutines will be round-tripped.\n" \
	" The 'main' function is reserved.\n" \
	"\"\"\"\n\n"

    return $script
}

# uiProcBegin --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::uiProcBegin {prefix args} {
    variable indent [string repeat " " 8]
    variable use_images
    variable use_vars

    # This is output when we want to create a stand-alone script
    set baseclass [string toupper $prefix 0 0]

    append script "# Using new-style classes: create empty base class object\n"
    append script "# for compatibility with older python interps\n"
    append script "#if sys.version_info < (2, 2):\n"
    append script "#    class object:\n"
    append script "#        pass\n\n"

    append script "class ${baseclass}(object):\n"
    append script "    _images = \[\] \# Holds image refs to prevent GC\n"
    append script "    def __init__(self, root):\n"
    # These come from textvariables - we need to create magic linked vars
    foreach var [lsort -unique $use_vars] {
	append script "${indent}self.$var = Tkinter.StringVar(root)\n"
    }
    foreach img [lsort -dictionary [array names use_images]] {
	# This image should already be created by name
	append script "${indent}self._images.append(Tkinter.PhotoImage('$img', file = $use_images($img)))\n"
    }

    return $script
}

# uiProcEnd --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::uiProcEnd {args} {
    variable indent ""
    return "\n"
}

# widget --
#
#   Handles instantiation of a widget
#
# Arguments:
#   type	type of widget
#   name	name of widget
#   master	parent widget
#   options	list of {option value} pairs
# Results:
#   Returns script to instantiate widget
#
proc ::compile::tkinter::widget {type name master options args} {
    variable indent
    variable widget_cmds

    # start of widget command
    set wcmd [::widget::get $type instance]

    set script ""
    append script "${indent}self.$name = ${wcmd}(${master},"

    # setting of options
    set in2 "${indent}    "
    foreach {opt value} $options {
	set opt [string trimleft $opt -]
	if {[regexp command $opt]} {
	    if {[string match "< * >" $value]} {
		switch [lindex $value 1] {
		    scroll {
			set w [::widget::data [lindex $value 2] ID]
			set value "$w.[lindex $value 3]"
		    }
		    command {
			set value "\\&[lindex $value 2]_[lindex $value 3]"
		    }
		}
	    } elseif {$value == ""} {
		set value "${name}_$opt"
	    }
	    # prepend 'self.' to all values
	    set value "self.$value"
	    append widget_cmds "\n${indent}self.$name.configure(\n${in2}$opt = $value\n${indent})"
	} elseif {[string match "*variable" $opt]} {
	    # textvariable, listvariable, variable
	    append script "\n${in2}$opt = self.$value,"
	} else {
	    if {$opt eq "from"} {
		# from is a keyword
		set opt "from_"
	    }
	    append script "\n${in2}$opt = [quote $value],"
	}
    }

    # end of widget command
    append script "\n${indent})\n"

    return $script
}

# bindtags --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::bindtags {type name tags args} {
    variable indent
    variable bindtags

    append bindtags "${indent}$name.bindtags(\[$tags\])\n"
    return ""
}

# postWidgets --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::postWidgets {args} {
    variable indent
    variable bindtags
    variable widget_cmds

    set script ""

    # ok, now we can set all the commands without worrying about
    # undefined widgets

    if {$widget_cmds != ""} {
	append script "\n${indent}# widget commands\n$widget_cmds\n"
    }

    # print out any binding tags
    # Note: user needs to use tkinterish tags here:
    # $b for .b
    # $b->toplevel for .
    # 'all' for all
    # if b is a Button, ref($b) for Button
    # all put into a comma delimited list

    if {$bindtags != ""} {
	append script "\n${indent}# binding tags\n\n$bindtags\n"
    }

    return $script
}

# menu --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::menu {master type options args} {
    variable indent

    set script ""
    #set script "\n${indent}# $name menu definition\n${indent}#\n"
    # THIS MUST BE IMPLEMENTED CORRECTLY ON THE tkinter/TK SIDE
    append script "${indent}self.$master.add_$type\("
    foreach {opt value} $options {
	set opt [string trimleft $opt -]
	if {$opt eq "menu"} {
	    append script "\n${indent}    $opt = self.$value,"
	} elseif {[regexp command $opt]} {
	    # Don't quote command values
	    append script "\n${indent}    $opt = $value,"
	} else {
	    append script "\n${indent}    $opt = [quote $value],"
	}
    }
    append script "\n${indent}\)\n"

    return $script
}

# attachmenu --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::attachmenu {name args} {
    variable indent

    set script ""
    append script "${indent}root.configure(menu = self.$name)\n"
    return $script
}

# geometry --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::geometry {name master row column options args} {
    variable indent

    set script ""

    append script "${indent}self.$name.grid(\n"
    append script "${indent}    in_    = $master,\n"
    append script "${indent}    column = $column,\n"
    append script "${indent}    row    = $row"
    foreach {opt value} $options {
	set opt [string trimleft $opt -]
	append script ",\n${indent}    $opt = [quote $value]"
    }
    append script "\n${indent})\n"

    return $script
}

# resizing --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::resizing {master dim weights minsizes pads args} {
    variable indent

    set script ""

    # We start at 1, although it is 0-based, to allow for
    # the expert user to fiddle with padding the 0 index.
    set index 0
    foreach weight $weights \
	    size   $minsizes \
	    pad    $pads {
	# original tkinter gen limits weight to max 1.
	append script "${indent}$master.grid_${dim}configure([incr index],\
		weight = $weight, minsize = $size, pad = $pad)\n"
    }

    return $script
}

# standalone --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::standalone {prefix args} {
    variable indent
    set baseclass [string toupper $prefix 0 0]
    set customclass Custom$baseclass
    set script "\n"
    append script "def main():\n"
    append script "    # Standalone Code Initialization\n"
    append script "    # DO NOT EDIT\n"
    append script "    try: userinit()\n"
    append script "    except NameError: pass\n"
    append script "    root = Tk()\n"
    append script "    demo = ${customclass}(root)\n"
    append script "    root.title('$prefix')\n"
    append script "    try: run()\n"
    append script "    except NameError: pass\n"
    append script "    root.protocol('WM_DELETE_WINDOW', root.quit)\n"
    append script "    root.mainloop()\n\n"
    append script "if __name__ == '__main__': main()\n"

    return $script
}

# translate --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
# find the real master of this window, as the user may have changed its name.
proc ::compile::tkinter::translate {name} {
    if {$name == "" || [::gui::isContainer $name]} {
	return root
    } else {
	return self.$name
    }
}

# test --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::test {name {validate ""} args} {
    set exe $::tkinter::interpreter
    if {![file exists $exe]} {
	if {$exe == ""} {
	    status_message "No known python interpreter"
	} else {
	    status_message "Invalid python interpreter \"$exe\""
	}
	return 0
    }

    # compute frame stacking and tabbing order
    set_frame_level $::W(FRAME)

    status_message "Starting test application"

    kill_test

    set file [::project::get include]

    busy_on "Running $exe $file ..."
    ::compile::runlog "Running $exe $file ...\n"
    update idletasks

    # We will capture both stdout and stderr in the fileevent
    if {[catch {open "|[list $exe] \"$file\" 2>@1" r+} fid]} {
	::compile::runlog "Execution failed for \"$file\":\n$fid\n"
	busy_off "Execution failed for \"$file\""
	kill_test
	return 0
    } else {
	set ::tkinter::fid $fid
	# Watch the test to see if the user kills it off without
	# using our Stop button.
	fconfigure $fid -blocking 0
	fileevent $fid readable [list ::compile::read_test $fid]
    }
    busy_off "Running $exe $file ..."
    return 1
}

# kill_test --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::kill_test {args} {
    if {[info exists ::tkinter::fid]} {
	catch {kill [pid $::tkinter::fid]}
	catch {close $::tkinter::fid}
	unset ::tkinter::fid
    }
    disable_kill_test
}

# isTestRunning --
#
#   ADD COMMENTS HERE
#
# Arguments:
#   args	comments
# Results:
#   Returns ...
#
proc ::compile::tkinter::isTestRunning {args} {
    return [info exists ::tkinter::fid]
}

proc ::compile::tkinter::_wslen {ws} {
    # return the length of whitespace in a line
    # by converting tabs to 8 spaces
    return [string length [string map [list "\t" "        "] $ws]]
}

# parseCallbacks --
#
#	parses the callbacks code.
#
# Arguments:
#
proc ::compile::tkinter::parseCallbacks {code} {
    variable CMDS ; array unset CMDS

    # this regexp parses "[ws]def[ws]funcName(args):"
    set partdefExp {^(\s*)def\s+(\w+)\s*\((.*)$}
    set enddefExp  {([^\)]*)\)\s*:}

    set incmd    0
    set lines    [split $code \n]
    set numLines [llength $lines]
    catch {unset autoAppend}
    for {set i 0} {$i < $numLines} {incr i} {
	set line [lindex $lines $i]
	if {[info exists autoAppend]} {
	    # Handle line continuation character
	    append $autoAppend "$line\n"
	    if {![string match "*\\\\" $line]} {
		unset autoAppend
	    }
	    continue
	}
	if {$incmd} {
	    regexp {^(\s*)} $line ws
	    if {[_wslen $ws] > $wslen} {
		# More whitespace than the original 'def' line,
		# so unequivocally add it to the body of the current func.
		if {$comments != ""} {
		    # add any stored comments with irregular whitespace.
		    append body $comments
		    set comments ""
		}
		append body "$line\n"
		if {[string match "*\\\\" $line]} {
		    set autoAppend body
		}
	    } elseif {[regexp {^\s*(\#.*)?$} $line]} {
		# This is an empty or comment line with less whitespace
		# than it should have - but it might still be part of the
		# command.  Just cache it for now - if we remain in this
		# function, this will be preserved.
		append comments "$line\n"
	    } else {
		# !empty line or the whitespace level was reduced, so do
		# not consider ourselves in this command anymore.  Remove
		# all trailing whitespace from the body.
		set CMDS($name) [list $arglist [string trimright $body]]
		set incmd 0
	    }
	}
	if {!$incmd && [regexp $partdefExp $line -> ws func funcargs]} {
	    # We have found a line creating a new function
	    set wslen    [_wslen $ws]
	    if {!$wslen} {
		# Do not preserve global functions ...
		continue
	    }
	    set incmd    1
	    set name     $func
	    set body     ""
	    set comments ""
	    if {[regexp $enddefExp $funcargs -> funcargs]} {
		set arglist $funcargs
	    } else {
		set arglist $funcargs
		for {incr i} {$i < $numLines} {incr i} {
		    set line [lindex $lines $i]
		    if {[regexp $enddefExp $line -> funcargs]} {
			append arglist "\n$funcargs"
			break
		    } else {
			append arglist "\n$line"
		    }
		}
	    }
	}
    }
    if {$incmd} {
	# store the last command that we were working on
	# Remove all trailing whitespace from the body.
	set CMDS($name) [list $arglist [string trimright $body]]
    }
}

# parseInclude --
#
#	parses the callbacks file.
#	this file may have user-defined code and must first be parsed
#	before we can write it out again.
#
# Arguments:
#
#  prefix	The procedure prefix (project name)
#  file		include file to parse
#
proc ::compile::tkinter::parseInclude {prefix file} {
    if {[catch {open $file r} fd]} {
	return -code error "Cannot open '$file' for reading:\n$fd"
    }

    # Here we would check the format if we used an ID
    set file [file tail $file]
    set line [gets $fd]
    set fmt  "\"\"\" $file --*"
    if {![string match $fmt $line]} {
	set i 0
	if {[string match "#!/*" $line]} {
	    # Try to skip past a unix #!/bin/sh style header, not more
	    # than 5 lines though, looking for the id.
	    while {[gets $fd line] != -1 && [incr i] < 5} {
		if {[string match $fmt $line]} {
		    break
		}
	    }
	}
	if {$i == 0 || $i >= 5} {
	    # We never found the format id.
	    seek $fd 0
	    set answer [tk_messageBox -title "Overwrite Include File?" \
		    -type yesno -icon warning \
		    -message "Include file '$file' may not be in a parseable\
		    format.\nShall I attempt to parse anyway?"]
	    if {$answer == "no"} {
		close $fd
		return -code error "Aborted parsing of '$file'"
	    }
	}
    }

    # Read in the remaining data.
    set data [read $fd]
    close $fd

    variable CODE ; array unset CODE
    variable CMDS ; array unset CMDS

    # this regexp parses "[ws]def[ws]funcName(args):"
    set partdefExp {^(\s*)def\s+(\w+)\s*\((.*)$}
    set enddefExp  {([^\)]*)\)\s*:}

    # Catch all code with user/callback code comment blocks
    set exp {(?w)^(\s*)\# BEGIN (USER|CALLBACK) CODE( ?)(\w*)\n(.*)^\1\# END \2 CODE\3\4$}

    set blocks [regexp -all -inline $exp $data]
    if {[llength $blocks]} {
	foreach {match space type s name code} $blocks {
	    if {$type eq "USER"} {
		set CODE($name) [string trimright $code]
	    } elseif {$type eq "CALLBACK"} {
		parseCallbacks [string trimright $code]
	    } else {
		return -code error "Unexpected code block '$type'"
	    }
	}
    } else {
	# We are going to assume that this is older code that we will
	# try and convert the old way
	parseCallbacks $data
    }
    return
}

# ::compile::$lang::compileInclude --
#
#	generate the callbacks file.
#	this file may have user-defined code and must first be parsed
#	before we can write it out again.
#
# Arguments:
#
#  prefix	The procedure prefix (project name)
#  autocmds	Commands that the app needs to have at least stubs for
#  uiFile	the unix file containing the ui description
#  targetFile	The language-specific file to write
#  includeFile	Optional include file
#
proc ::compile::tkinter::compileInclude {
    prefix autocmds uiFile targetFile includeFile
} {

    # populated by parseInclude
    variable CMDS ; array unset CMDS
    variable CODE ; array unset CODE

    if {[file exists $includeFile] && [file size $includeFile]} {
	# This may return an error, which I let filter up at this point
	parseInclude $prefix $includeFile
    }

    set targetModule [file rootname [file tail $targetFile]]
    set baseclass    [string toupper $prefix 0 0]
    set customclass  "Custom$baseclass"

    # This will contain the end script
    set script ""

    # Allow for language specific code generation initialization
    append script [init include $includeFile]

    # Script header
    append script [includeHeader $includeFile $uiFile $prefix]

    # import/from statements in user code
    foreach module [lsort -dictionary [array names FROM]] {
	if {$module eq "Tkinter" || $module eq $targetModule} continue
	append script "$FROM($module)"
    }

    # Include ui generated file if one was specified.
    append script "from Tkinter import *\n"
    append script "from $targetModule import $baseclass\n"

    # User code block - global
    append script "\n# BEGIN USER CODE global\n"
    if {[info exists CODE(global)]} {
	append script $CODE(global)
    }
    append script "\n# END USER CODE global\n"

    variable indent "    "
    append script "\nclass ${customclass}($baseclass):\n"
    append script "${indent}pass\n"

    # Callback code block
    append script "\n${indent}# BEGIN CALLBACK CODE\n" \
	"${indent}# ONLY EDIT CODE INSIDE THE def FUNCTIONS.\n"
    foreach cmd [lsort -dictionary $autocmds] {
	append script "\n"
	# Create main proc
	if {[llength $cmd] == 2} {
	    # This is the $widget $option variety
	    foreach {widget option} $cmd break
	    set name    "${widget}_[string trimleft ${option} -]"
	    set arglist "self, *args"
	    set body    ""
	    set comment "Callback to handle $widget widget option $option"
	    if {[info exists CMDS($name)]} {
		foreach {arglist body} $CMDS($name) break
		# remove this reference after processing it
		unset CMDS($name)
	    }
	    append script [command $prefix $name $arglist $body $comment]
	} else {
	    # Don't know what to do with this yet
	    append script [comment "Callback to handle:\n$cmd"]
	}
    }
    foreach name [lsort -dictionary [array names CMDS]] {
	append script "\n"
	set arglist ""
	set body    ""
	foreach {arglist body} $CMDS($name) break
	append script [command $prefix $name $arglist $body \
			   "Legacy command found in callback code.\
			    Add user comments inside body."]
    }
    append script "\n${indent}# END CALLBACK CODE\n"

    # User code block - class
    append script "\n${indent}# BEGIN USER CODE class\n"
    if {[info exists CODE(class)]} {
	append script $CODE(class)
    }
    append script "\n${indent}# END USER CODE class\n"

    # Standalone code block
    append script [standalone $prefix]

    return $script
}
